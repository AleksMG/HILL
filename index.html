<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Усовершенствованный шифр Хилла</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .section {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        textarea, input, button, select {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            box-sizing: border-box;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            padding: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        .matrix-input {
            display: grid;
            gap: 5px;
            margin: 10px 0;
        }
        .matrix-input input {
            text-align: center;
        }
        .result {
            background-color: #f9f9f9;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
            word-break: break-all;
        }
        .flex-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .flex-row > * {
            flex: 1;
        }
        .status-good {
            color: green;
        }
        .status-bad {
            color: red;
        }
        .status-warning {
            color: orange;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Усовершенствованный шифр Хилла</h1>
        
        <div class="section">
            <h2>Настройки шифра</h2>
            <div class="flex-row">
                <div>
                    <label for="block-size">Размер блока:</label>
                    <select id="block-size">
                        <option value="4">4 символа (рекомендуется)</option>
                        <option value="3">3 символа</option>
                        <option value="5">5 символов</option>
                    </select>
                </div>
                <div>
                    <label for="rounds">Количество раундов:</label>
                    <select id="rounds">
                        <option value="3">3 (рекомендуется)</option>
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="4">4</option>
                        <option value="5">5</option>
                    </select>
                </div>
                <div>
                    <label for="modulo">Модуль:</label>
                    <select id="modulo">
                        <option value="256">256 (байты)</option>
                        <option value="26">26 (A-Z)</option>
                    </select>
                </div>
            </div>
            <div class="flex-row">
                <div>
                    <label for="mode">Режим:</label>
                    <select id="mode">
                        <option value="CBC">CBC (рекомендуется)</option>
                        <option value="ECB">ECB</option>
                    </select>
                </div>
                <div>
                    <label for="iv">Вектор инициализации (IV):</label>
                    <input type="text" id="iv" placeholder="Случайные значения">
                </div>
            </div>
            <button id="generate-keys">Сгенерировать новые ключи</button>
        </div>
        
        <div class="section">
            <h2>Ключевые матрицы (для каждого раунда)</h2>
            <div id="matrices-container"></div>
            <div id="matrix-status" class="result"></div>
        </div>
        
        <div class="section">
            <h2>S-Box (подстановочная таблица)</h2>
            <textarea id="sbox-input" rows="3" placeholder="Введите значения через запятую (0-255)"></textarea>
            <div id="sbox-status" class="result"></div>
        </div>
        
        <div class="section">
            <h2>Шифрование/Дешифрование</h2>
            <label for="input-type">Тип ввода:</label>
            <select id="input-type">
                <option value="text">Текст</option>
                <option value="hex">HEX</option>
            </select>
            <textarea id="input-text" rows="4" placeholder="Введите текст или HEX-данные"></textarea>
            <div class="flex-row">
                <button id="encrypt-btn">Зашифровать</button>
                <button id="decrypt-btn">Расшифровать</button>
            </div>
            <div class="result" id="output-text"></div>
            <button id="copy-output">Копировать результат</button>
        </div>
    </div>

    <script>
        // Инициализация элементов
        const blockSizeSelect = document.getElementById('block-size');
        const roundsSelect = document.getElementById('rounds');
        const moduloSelect = document.getElementById('modulo');
        const modeSelect = document.getElementById('mode');
        const ivInput = document.getElementById('iv');
        const generateKeysBtn = document.getElementById('generate-keys');
        const matricesContainer = document.getElementById('matrices-container');
        const matrixStatus = document.getElementById('matrix-status');
        const sboxInput = document.getElementById('sbox-input');
        const sboxStatus = document.getElementById('sbox-status');
        const inputTypeSelect = document.getElementById('input-type');
        const inputText = document.getElementById('input-text');
        const encryptBtn = document.getElementById('encrypt-btn');
        const decryptBtn = document.getElementById('decrypt-btn');
        const outputText = document.getElementById('output-text');
        const copyOutputBtn = document.getElementById('copy-output');
        
        // Глобальные переменные
        let matrices = [];
        let sbox = [];
        let inverseSbox = [];
        
        // Инициализация при загрузке
        document.addEventListener('DOMContentLoaded', () => {
            updateMatricesUI();
            generateDefaultSBox();
            generateRandomIV();
        });
        
        // Обновление интерфейса матриц
        function updateMatricesUI() {
            matricesContainer.innerHTML = '';
            const blockSize = parseInt(blockSizeSelect.value);
            const rounds = parseInt(roundsSelect.value);
            
            for (let round = 0; round < rounds; round++) {
                const roundSection = document.createElement('div');
                roundSection.className = 'section';
                roundSection.innerHTML = `<h3>Раунд ${round + 1}</h3>`;
                
                const matrixDiv = document.createElement('div');
                matrixDiv.className = 'matrix-input';
                matrixDiv.style.gridTemplateColumns = `repeat(${blockSize}, 1fr)`;
                
                // Создаем или обновляем матрицу для этого раунда
                if (!matrices[round]) {
                    matrices[round] = generateRandomMatrix(blockSize);
                }
                
                // Создаем инпуты для матрицы
                for (let i = 0; i < blockSize; i++) {
                    for (let j = 0; j < blockSize; j++) {
                        const input = document.createElement('input');
                        input.type = 'number';
                        input.id = `m${round}_${i}${j}`;
                        input.value = matrices[round][i][j];
                        input.addEventListener('change', () => {
                            matrices[round][i][j] = parseInt(input.value);
                            checkAllMatrices();
                        });
                        matrixDiv.appendChild(input);
                    }
                }
                
                roundSection.appendChild(matrixDiv);
                matricesContainer.appendChild(roundSection);
            }
            
            checkAllMatrices();
        }
        
        // Генерация случайной матрицы
        function generateRandomMatrix(size) {
            const matrix = [];
            const modulo = parseInt(moduloSelect.value);
            
            for (let i = 0; i < size; i++) {
                const row = [];
                for (let j = 0; j < size; j++) {
                    row.push(Math.floor(Math.random() * modulo));
                }
                matrix.push(row);
            }
            
            // Убедимся, что матрица обратима
            while (!isMatrixInvertible(matrix, modulo)) {
                return generateRandomMatrix(size);
            }
            
            return matrix;
        }
        
        // Проверка всех матриц на обратимость
        function checkAllMatrices() {
            const modulo = parseInt(moduloSelect.value);
            let allValid = true;
            
            for (let round = 0; round < matrices.length; round++) {
                if (!isMatrixInvertible(matrices[round], modulo)) {
                    matrixStatus.textContent = `Ошибка: матрица раунда ${round + 1} необратима по модулю ${modulo}`;
                    matrixStatus.className = 'result status-bad';
                    allValid = false;
                    break;
                }
            }
            
            if (allValid) {
                matrixStatus.textContent = `Все матрицы обратимы по модулю ${modulo}`;
                matrixStatus.className = 'result status-good';
            }
        }
        
        // Проверка обратимости матрицы
        function isMatrixInvertible(matrix, modulo) {
            const det = calculateDeterminant(matrix);
            return gcd(det, modulo) === 1;
        }
        
        // Вычисление определителя матрицы
        function calculateDeterminant(matrix) {
            const size = matrix.length;
            
            if (size === 1) return matrix[0][0];
            if (size === 2) {
                return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];
            }
            
            let det = 0;
            for (let i = 0; i < size; i++) {
                const minor = [];
                for (let j = 1; j < size; j++) {
                    const row = [];
                    for (let k = 0; k < size; k++) {
                        if (k !== i) row.push(matrix[j][k]);
                    }
                    minor.push(row);
                }
                det += (i % 2 === 0 ? 1 : -1) * matrix[0][i] * calculateDeterminant(minor);
            }
            
            return det;
        }
        
        // НОД (алгоритм Евклида)
        function gcd(a, b) {
            a = Math.abs(a);
            b = Math.abs(b);
            while (b) {
                const t = b;
                b = a % b;
                a = t;
            }
            return a;
        }
        
        // Обратная матрица по модулю
        function inverseMatrix(matrix, modulo) {
            const size = matrix.length;
            const det = calculateDeterminant(matrix);
            const detInv = modInverse(det, modulo);
            
            // Матрица алгебраических дополнений
            const adjugate = [];
            for (let i = 0; i < size; i++) {
                const row = [];
                for (let j = 0; j < size; j++) {
                    const minor = [];
                    for (let k = 0; k < size; k++) {
                        if (k === i) continue;
                        const minorRow = [];
                        for (let l = 0; l < size; l++) {
                            if (l === j) continue;
                            minorRow.push(matrix[k][l]);
                        }
                        minor.push(minorRow);
                    }
                    const sign = (i + j) % 2 === 0 ? 1 : -1;
                    row.push(sign * calculateDeterminant(minor));
                }
                adjugate.push(row);
            }
            
            // Транспонирование и умножение на обратный детерминант
            const inverse = [];
            for (let i = 0; i < size; i++) {
                const row = [];
                for (let j = 0; j < size; j++) {
                    row.push(positiveMod(adjugate[j][i] * detInv, modulo));
                }
                inverse.push(row);
            }
            
            return inverse;
        }
        
        // Обратный элемент в кольце вычетов
        function modInverse(a, m) {
            a = positiveMod(a, m);
            for (let x = 1; x < m; x++) {
                if ((a * x) % m === 1) {
                    return x;
                }
            }
            return 1;
        }
        
        // Положительный модуль
        function positiveMod(n, m) {
            return ((n % m) + m) % m;
        }
        
        // Генерация S-Box по умолчанию
        function generateDefaultSBox() {
            const modulo = parseInt(moduloSelect.value);
            const sbox = [];
            
            // Генерируем перестановку 0..modulo-1
            for (let i = 0; i < modulo; i++) sbox.push(i);
            
            // Перемешиваем Fisher-Yates
            for (let i = sbox.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [sbox[i], sbox[j]] = [sbox[j], sbox[i]];
            }
            
            sboxInput.value = sbox.join(', ');
            validateSBox();
        }
        
        // Проверка и создание S-Box
        function validateSBox() {
            const modulo = parseInt(moduloSelect.value);
            const values = sboxInput.value.split(',').map(v => parseInt(v.trim()));
            
            if (values.length !== modulo) {
                sboxStatus.textContent = `Ошибка: нужно ровно ${modulo} значений`;
                sboxStatus.className = 'result status-bad';
                return false;
            }
            
            const unique = new Set(values);
            if (unique.size !== modulo) {
                sboxStatus.textContent = "Ошибка: значения должны быть уникальными";
                sboxStatus.className = 'result status-bad';
                return false;
            }
            
            for (const val of values) {
                if (isNaN(val) || val < 0 || val >= modulo) {
                    sboxStatus.textContent = `Ошибка: значения должны быть числами от 0 до ${modulo-1}`;
                    sboxStatus.className = 'result status-bad';
                    return false;
                }
            }
            
            sbox = values;
            createInverseSBox();
            sboxStatus.textContent = "S-Box валидна";
            sboxStatus.className = 'result status-good';
            return true;
        }
        
        // Создание обратного S-Box
        function createInverseSBox() {
            const modulo = parseInt(moduloSelect.value);
            inverseSbox = new Array(modulo);
            for (let i = 0; i < modulo; i++) {
                inverseSbox[sbox[i]] = i;
            }
        }
        
        // Генерация случайного IV
        function generateRandomIV() {
            const blockSize = parseInt(blockSizeSelect.value);
            const modulo = parseInt(moduloSelect.value);
            let iv = '';
            
            for (let i = 0; i < blockSize; i++) {
                iv += Math.floor(Math.random() * modulo) + (i < blockSize-1 ? ',' : '');
            }
            
            ivInput.value = iv;
        }
        
        // Преобразование текста в числа
        function textToNumbers(text, modulo) {
            if (modulo === 26) {
                return text.toUpperCase().replace(/[^A-Z]/g, '').split('').map(c => c.charCodeAt(0) - 65);
            } else {
                // Для modulo 256 работаем с байтами
                const bytes = new TextEncoder().encode(text);
                return Array.from(bytes);
            }
        }
        
        // Преобразование чисел в текст
        function numbersToText(numbers, modulo) {
            if (modulo === 26) {
                return numbers.map(n => String.fromCharCode(n + 65)).join('');
            } else {
                // Для modulo 256 работаем с байтами
                const bytes = new Uint8Array(numbers);
                return new TextDecoder().decode(bytes);
            }
        }
        
        // Преобразование HEX в числа
        function hexToNumbers(hex) {
            const bytes = [];
            for (let i = 0; i < hex.length; i += 2) {
                bytes.push(parseInt(hex.substr(i, 2), 16));
            }
            return bytes;
        }
        
        // Преобразование чисел в HEX
        function numbersToHex(numbers) {
            return numbers.map(n => n.toString(16).padStart(2, '0')).join('');
        }
        
        // Применение S-Box
        function applySBox(numbers) {
            return numbers.map(n => sbox[n]);
        }
        
        // Обратное применение S-Box
        function applyInverseSBox(numbers) {
            return numbers.map(n => inverseSbox[n]);
        }
        
        // Шифрование блока
        function encryptBlock(block, matrix, modulo) {
            const size = matrix.length;
            const result = new Array(size).fill(0);
            
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    result[i] += matrix[i][j] * block[j];
                }
                result[i] = positiveMod(result[i], modulo);
            }
            
            return result;
        }
        
        // Дешифрование блока
        function decryptBlock(block, inverseMatrix, modulo) {
            return encryptBlock(block, inverseMatrix, modulo);
        }
        
        // Основная функция шифрования
        function encrypt() {
            if (!validateSBox()) return;
            checkAllMatrices();
            if (matrixStatus.className.includes('bad')) return;
            
            const blockSize = parseInt(blockSizeSelect.value);
            const rounds = parseInt(roundsSelect.value);
            const modulo = parseInt(moduloSelect.value);
            const mode = modeSelect.value;
            const iv = ivInput.value.split(',').map(v => parseInt(v.trim()));
            
            if (mode === 'CBC' && iv.length !== blockSize) {
                outputText.textContent = "Ошибка: неверная длина вектора инициализации (IV)";
                return;
            }
            
            let inputData;
            if (inputTypeSelect.value === 'text') {
                inputData = textToNumbers(inputText.value, modulo);
            } else {
                inputData = hexToNumbers(inputText.value.replace(/[^0-9a-fA-F]/g, ''));
            }
            
            if (inputData.length === 0) {
                outputText.textContent = "Ошибка: нет данных для шифрования";
                return;
            }
            
            // Дополнение до кратного blockSize
            const paddingLength = (blockSize - (inputData.length % blockSize)) % blockSize;
            const paddedData = [...inputData, ...Array(paddingLength).fill(modulo - 1)];
            
            // Применение S-Box перед шифрованием
            let processedData = applySBox(paddedData);
            
            // Разбиение на блоки и шифрование
            let encryptedData = [];
            let previousBlock = mode === 'CBC' ? iv : null;
            
            for (let i = 0; i < processedData.length; i += blockSize) {
                let block = processedData.slice(i, i + blockSize);
                
                // CBC режим: XOR с предыдущим блоком
                if (mode === 'CBC' && previousBlock) {
                    block = block.map((val, idx) => val ^ previousBlock[idx]);
                }
                
                // Многократное шифрование (раунды)
                for (let round = 0; round < rounds; round++) {
                    block = encryptBlock(block, matrices[round], modulo);
                    if (round < rounds - 1) {
                        block = applySBox(block);
                    }
                }
                
                encryptedData.push(...block);
                previousBlock = block;
            }
            
            // Вывод результата
            if (inputTypeSelect.value === 'text') {
                outputText.textContent = numbersToText(encryptedData, modulo);
            } else {
                outputText.textContent = numbersToHex(encryptedData);
            }
        }
        
        // Основная функция дешифрования
        function decrypt() {
            if (!validateSBox()) return;
            checkAllMatrices();
            if (matrixStatus.className.includes('bad')) return;
            
            const blockSize = parseInt(blockSizeSelect.value);
            const rounds = parseInt(roundsSelect.value);
            const modulo = parseInt(moduloSelect.value);
            const mode = modeSelect.value;
            const iv = ivInput.value.split(',').map(v => parseInt(v.trim()));
            
            if (mode === 'CBC' && iv.length !== blockSize) {
                outputText.textContent = "Ошибка: неверная длина вектора инициализации (IV)";
                return;
            }
            
            let inputData;
            if (inputTypeSelect.value === 'text') {
                inputData = textToNumbers(inputText.value, modulo);
            } else {
                inputData = hexToNumbers(inputText.value.replace(/[^0-9a-fA-F]/g, ''));
            }
            
            if (inputData.length === 0 || inputData.length % blockSize !== 0) {
                outputText.textContent = "Ошибка: некорректная длина зашифрованных данных";
                return;
            }
            
            // Генерируем обратные матрицы для каждого раунда
            const inverseMatrices = [];
            for (let round = 0; round < rounds; round++) {
                inverseMatrices.unshift(inverseMatrix(matrices[round], modulo));
            }
            
            // Разбиение на блоки и дешифрование
            let decryptedData = [];
            let previousBlock = mode === 'CBC' ? iv : null;
            
            for (let i = 0; i < inputData.length; i += blockSize) {
                let block = inputData.slice(i, i + blockSize);
                let saveBlock = [...block];
                
                // Многократное дешифрование (раунды в обратном порядке)
                for (let round = 0; round < rounds; round++) {
                    if (round > 0) {
                        block = applyInverseSBox(block);
                    }
                    block = decryptBlock(block, inverseMatrices[round], modulo);
                }
                
                // CBC режим: XOR с предыдущим зашифрованным блоком
                if (mode === 'CBC' && previousBlock) {
                    block = block.map((val, idx) => val ^ previousBlock[idx]);
                }
                
                decryptedData.push(...block);
                previousBlock = saveBlock;
            }
            
            // Удаление дополнения
            let padding = 0;
            if (decryptedData.length > 0) {
                const lastByte = decryptedData[decryptedData.length - 1];
                if (lastByte === modulo - 1) {
                    padding = 1;
                    // Проверяем, не было ли нескольких одинаковых байтов дополнения
                    for (let i = decryptedData.length - 2; i >= 0 && decryptedData[i] === modulo - 1; i--) {
                        padding++;
                    }
                }
            }
            const finalData = decryptedData.slice(0, decryptedData.length - padding);
            
            // Вывод результата
            if (inputTypeSelect.value === 'text') {
                outputText.textContent = numbersToText(finalData, modulo);
            } else {
                outputText.textContent = numbersToHex(finalData);
            }
        }
        
        // Обработчики событий
        blockSizeSelect.addEventListener('change', () => {
            matrices = [];
            updateMatricesUI();
            generateRandomIV();
        });
        
        roundsSelect.addEventListener('change', () => {
            matrices = [];
            updateMatricesUI();
        });
        
        moduloSelect.addEventListener('change', () => {
            matrices = [];
            updateMatricesUI();
            generateDefaultSBox();
            generateRandomIV();
        });
        
        generateKeysBtn.addEventListener('click', () => {
            matrices = [];
            updateMatricesUI();
            generateDefaultSBox();
            generateRandomIV();
        });
        
        sboxInput.addEventListener('input', validateSBox);
        
        encryptBtn.addEventListener('click', encrypt);
        decryptBtn.addEventListener('click', decrypt);
        
        copyOutputBtn.addEventListener('click', () => {
            navigator.clipboard.writeText(outputText.textContent)
                .then(() => alert("Результат скопирован в буфер обмена"))
                .catch(err => alert("Ошибка копирования: " + err));
        });
    </script>
</body>
</html>
