<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Улучшенный шифр Хилла с раундовыми ключами</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .section {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        textarea, input, button, select {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            box-sizing: border-box;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            padding: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        .matrix-input {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin: 10px 0;
        }
        .matrix-input input {
            text-align: center;
        }
        .result {
            background-color: #f9f9f9;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
            word-break: break-all;
        }
        .key-inputs {
            display: flex;
            gap: 10px;
        }
        .key-inputs > div {
            flex: 1;
        }
        .status {
            margin-top: 5px;
            font-size: 0.9em;
        }
        .valid {
            color: green;
        }
        .invalid {
            color: red;
        }
        .round-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Улучшенный шифр Хилла с раундовыми ключами</h1>
        
        <div class="section">
            <h2>Ключевые параметры</h2>
            <div class="key-inputs">
                <div>
                    <label for="main-key">Основной ключ:</label>
                    <input type="text" id="main-key" value="CRYPTOGRAPHY">
                    <div id="main-key-status" class="status"></div>
                </div>
            </div>
            <div class="round-controls">
                <label for="rounds">Количество раундов:</label>
                <select id="rounds">
                    <option value="2">2</option>
                    <option value="3" selected>3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                </select>
                <button id="show-rounds">Показать раундовые ключи</button>
            </div>
            <div id="round-keys-info" class="result" style="display:none;"></div>
        </div>
        
        <div class="section">
            <h2>Шифрование/Дешифрование</h2>
            <textarea id="input-text" rows="4" placeholder="Введите текст (только буквы A-Z)"></textarea>
            <button id="encrypt-btn">Зашифровать</button>
            <button id="decrypt-btn">Расшифровать</button>
            <div class="result" id="output-text"></div>
        </div>
    </div>

    <script>
        // Инициализация элементов
        const mainKeyInput = document.getElementById('main-key');
        const mainKeyStatus = document.getElementById('main-key-status');
        const roundsSelect = document.getElementById('rounds');
        const showRoundsBtn = document.getElementById('show-rounds');
        const roundKeysInfo = document.getElementById('round-keys-info');
        const inputText = document.getElementById('input-text');
        const encryptBtn = document.getElementById('encrypt-btn');
        const decryptBtn = document.getElementById('decrypt-btn');
        const outputText = document.getElementById('output-text');
        
        // Проверка ключа
        function validateKey(key) {
            const cleanKey = key.toUpperCase().replace(/[^A-Z]/g, '');
            if (cleanKey.length < 6) {
                return { valid: false, message: "Ключ должен содержать хотя бы 6 букв" };
            }
            return { valid: true, key: cleanKey };
        }
        
        // Генерация раундовых ключей
        function generateRoundKeys(key, rounds) {
            const keys = [];
            const keyNumbers = Array.from(key).map(c => c.charCodeAt(0) - 65);
            
            for (let round = 0; round < rounds; round++) {
                // Создаем уникальную матрицу для каждого раунда
                const matrix = [];
                for (let i = 0; i < 3; i++) {
                    const row = [];
                    for (let j = 0; j < 3; j++) {
                        const index = (round * 9 + i * 3 + j) % keyNumbers.length;
                        let val = keyNumbers[index] + round * 7 + i * 5 + j * 3;
                        val = val % 26;
                        if (val < 0) val += 26;
                        row.push(val);
                    }
                    matrix.push(row);
                }
                keys.push(matrix);
            }
            
            return keys;
        }
        
        // Генерация S-Box для раунда
        function generateSBoxForRound(key, round) {
            let sbox = [];
            for (let i = 0; i < 26; i++) {
                sbox.push(i);
            }
            
            // Перемешивание с использованием ключа и номера раунда
            const keyNumbers = Array.from(key).map(c => c.charCodeAt(0) - 65);
            let currentIndex = sbox.length;
            
            while (currentIndex > 0) {
                const keyPart = keyNumbers[(round * 26 + currentIndex) % keyNumbers.length];
                const randomIndex = (keyPart + round * 17 + currentIndex * 13) % currentIndex;
                currentIndex--;
                
                [sbox[currentIndex], sbox[randomIndex]] = [sbox[randomIndex], sbox[currentIndex]];
            }
            
            return sbox;
        }
        
        // Проверка обратимости матрицы
        function isMatrixInvertible(matrix) {
            const a = matrix[0][0], b = matrix[0][1], c = matrix[0][2];
            const d = matrix[1][0], e = matrix[1][1], f = matrix[1][2];
            const g = matrix[2][0], h = matrix[2][1], i = matrix[2][2];
            
            const det = a*(e*i - f*h) - b*(d*i - f*g) + c*(d*h - e*g);
            return gcd(det, 26) === 1;
        }
        
        // НОД
        function gcd(a, b) {
            a = Math.abs(a);
            b = Math.abs(b);
            while (b) {
                const t = b;
                b = a % b;
                a = t;
            }
            return a;
        }
        
        // Обратная матрица по модулю 26
        function inverseMatrix(matrix) {
            const a = matrix[0][0], b = matrix[0][1], c = matrix[0][2];
            const d = matrix[1][0], e = matrix[1][1], f = matrix[1][2];
            const g = matrix[2][0], h = matrix[2][1], k = matrix[2][2];
            
            const det = a*(e*k - f*h) - b*(d*k - f*g) + c*(d*h - e*g);
            const detInv = modInverse(det, 26);
            
            const minor00 = (e*k - f*h) * detInv % 26;
            const minor01 = (d*k - f*g) * detInv % 26;
            const minor02 = (d*h - e*g) * detInv % 26;
            const minor10 = (b*k - c*h) * detInv % 26;
            const minor11 = (a*k - c*g) * detInv % 26;
            const minor12 = (a*h - b*g) * detInv % 26;
            const minor20 = (b*f - c*e) * detInv % 26;
            const minor21 = (a*f - c*d) * detInv % 26;
            const minor22 = (a*e - b*d) * detInv % 26;
            
            return [
                [positiveMod(minor00, 26), positiveMod(-minor10, 26), positiveMod(minor20, 26)],
                [positiveMod(-minor01, 26), positiveMod(minor11, 26), positiveMod(-minor21, 26)],
                [positiveMod(minor02, 26), positiveMod(-minor12, 26), positiveMod(minor22, 26)]
            ];
        }
        
        // Обратный элемент в кольце вычетов
        function modInverse(a, m) {
            a = positiveMod(a, m);
            for (let x = 1; x < m; x++) {
                if ((a * x) % m === 1) {
                    return x;
                }
            }
            return 1;
        }
        
        // Положительный модуль
        function positiveMod(n, m) {
            return ((n % m) + m) % m;
        }
        
        // Преобразование текста в числа
        function textToNumbers(text) {
            return text.toUpperCase().replace(/[^A-Z]/g, '').split('').map(c => c.charCodeAt(0) - 65);
        }
        
        // Преобразование чисел в текст
        function numbersToText(numbers) {
            return numbers.map(n => String.fromCharCode(n + 65)).join('');
        }
        
        // Применение S-Box
        function applySBox(numbers, sbox) {
            return numbers.map(n => sbox[n]);
        }
        
        // Обратное применение S-Box
        function applyInverseSBox(numbers, sbox) {
            const inverse = new Array(26);
            for (let i = 0; i < 26; i++) {
                inverse[sbox[i]] = i;
            }
            return numbers.map(n => inverse[n]);
        }
        
        // Шифрование блока
        function encryptBlock(block, matrix) {
            const result = [0, 0, 0];
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    result[i] += matrix[i][j] * block[j];
                }
                result[i] = positiveMod(result[i], 26);
            }
            return result;
        }
        
        // Дешифрование блока
        function decryptBlock(block, inverseMatrix) {
            return encryptBlock(block, inverseMatrix);
        }
        
        // Основная функция шифрования
        function encrypt() {
            const text = inputText.value;
            if (!text) {
                outputText.textContent = "Введите текст для шифрования";
                return;
            }
            
            const keyResult = validateKey(mainKeyInput.value);
            if (!keyResult.valid) {
                mainKeyStatus.textContent = keyResult.message;
                mainKeyStatus.className = 'status invalid';
                return;
            }
            mainKeyStatus.textContent = "Ключ валиден";
            mainKeyStatus.className = 'status valid';
            
            const rounds = parseInt(roundsSelect.value);
            const roundKeys = generateRoundKeys(keyResult.key, rounds);
            
            // Проверка всех матриц на обратимость
            for (let i = 0; i < roundKeys.length; i++) {
                if (!isMatrixInvertible(roundKeys[i])) {
                    outputText.textContent = `Ошибка: матрица для раунда ${i+1} необратима по модулю 26. Попробуйте другой ключ.`;
                    return;
                }
            }
            
            let numbers = textToNumbers(text);
            if (numbers.length === 0) {
                outputText.textContent = "Текст должен содержать буквы A-Z";
                return;
            }
            
            // Дополнение до кратного 3
            const paddingLength = (3 - (numbers.length % 3)) % 3;
            const paddedNumbers = [...numbers, ...Array(paddingLength).fill(23)]; // X
            
            // Шифрование с несколькими раундами
            let processedNumbers = [...paddedNumbers];
            
            for (let round = 0; round < rounds; round++) {
                const sbox = generateSBoxForRound(keyResult.key, round);
                const inverseSbox = generateSBoxForRound(keyResult.key, round + 100); // Разный S-Box для обратного преобразования
                
                // Применение S-Box
                processedNumbers = applySBox(processedNumbers, sbox);
                
                // Шифрование матрицей
                const encryptedBlocks = [];
                for (let i = 0; i < processedNumbers.length; i += 3) {
                    const block = processedNumbers.slice(i, i + 3);
                    const encryptedBlock = encryptBlock(block, roundKeys[round]);
                    encryptedBlocks.push(...encryptedBlock);
                }
                
                processedNumbers = encryptedBlocks;
                
                // Применение обратного S-Box (кроме последнего раунда)
                if (round < rounds - 1) {
                    processedNumbers = applyInverseSBox(processedNumbers, inverseSbox);
                }
            }
            
            outputText.textContent = numbersToText(processedNumbers);
        }
        
        // Основная функция дешифрования
        function decrypt() {
            const text = inputText.value;
            if (!text) {
                outputText.textContent = "Введите текст для дешифрования";
                return;
            }
            
            const keyResult = validateKey(mainKeyInput.value);
            if (!keyResult.valid) {
                mainKeyStatus.textContent = keyResult.message;
                mainKeyStatus.className = 'status invalid';
                return;
            }
            mainKeyStatus.textContent = "Ключ валиден";
            mainKeyStatus.className = 'status valid';
            
            const rounds = parseInt(roundsSelect.value);
            const roundKeys = generateRoundKeys(keyResult.key, rounds);
            
            // Генерация обратных матриц
            const inverseRoundKeys = roundKeys.map(matrix => inverseMatrix(matrix)).reverse();
            
            let numbers = textToNumbers(text);
            if (numbers.length === 0 || numbers.length % 3 !== 0) {
                outputText.textContent = "Некорректная длина зашифрованного текста";
                return;
            }
            
            // Дешифрование с несколькими раундами (в обратном порядке)
            let processedNumbers = [...numbers];
            
            for (let round = 0; round < rounds; round++) {
                const sboxRound = rounds - 1 - round;
                const sbox = generateSBoxForRound(keyResult.key, sboxRound + 100); // Обратный S-Box
                const inverseSbox = generateSBoxForRound(keyResult.key, sboxRound); // Прямой S-Box
                
                // Применение S-Box (кроме первого раунда)
                if (round > 0) {
                    processedNumbers = applySBox(processedNumbers, sbox);
                }
                
                // Дешифрование матрицей
                const decryptedBlocks = [];
                for (let i = 0; i < processedNumbers.length; i += 3) {
                    const block = processedNumbers.slice(i, i + 3);
                    const decryptedBlock = decryptBlock(block, inverseRoundKeys[round]);
                    decryptedBlocks.push(...decryptedBlock);
                }
                
                processedNumbers = decryptedBlocks;
                
                // Применение обратного S-Box
                processedNumbers = applyInverseSBox(processedNumbers, inverseSbox);
            }
            
            // Удаление дополнения
            let padding = 0;
            if (processedNumbers.length > 0) {
                const lastChar = processedNumbers[processedNumbers.length - 1];
                if (lastChar === 23) {
                    padding = 1;
                    for (let i = processedNumbers.length - 2; i >= 0 && processedNumbers[i] === 23; i--) {
                        padding++;
                    }
                }
            }
            const finalNumbers = processedNumbers.slice(0, processedNumbers.length - padding);
            
            outputText.textContent = numbersToText(finalNumbers);
        }
        
        // Показать раундовые ключи
        function showRoundKeys() {
            const keyResult = validateKey(mainKeyInput.value);
            if (!keyResult.valid) {
                roundKeysInfo.textContent = keyResult.message;
                roundKeysInfo.style.display = 'block';
                return;
            }
            
            const rounds = parseInt(roundsSelect.value);
            const roundKeys = generateRoundKeys(keyResult.key, rounds);
            
            let info = `<h3>Раундовые ключи (${rounds}):</h3>`;
            
            for (let i = 0; i < roundKeys.length; i++) {
                info += `<p><strong>Раунд ${i+1}:</strong><br>`;
                info += `Матрица: [${roundKeys[i][0].join(', ')}], [${roundKeys[i][1].join(', ')}], [${roundKeys[i][2].join(', ')}]<br>`;
                
                const sbox = generateSBoxForRound(keyResult.key, i);
                info += `S-Box: ${sbox.join(', ')}</p>`;
            }
            
            roundKeysInfo.innerHTML = info;
            roundKeysInfo.style.display = 'block';
        }
        
        // Обработчики событий
        showRoundsBtn.addEventListener('click', showRoundKeys);
        encryptBtn.addEventListener('click', encrypt);
        decryptBtn.addEventListener('click', decrypt);
        
        // Инициализация при загрузке
        document.addEventListener('DOMContentLoaded', () => {
            const keyResult = validateKey(mainKeyInput.value);
            if (keyResult.valid) {
                mainKeyStatus.textContent = "Ключ валиден";
                mainKeyStatus.className = 'status valid';
            }
        });
    </script>
</body>
</html>
