<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Профессиональная реализация шифра Хилла</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }
        h1, h2 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        .section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #fafafa;
        }
        .matrix-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin: 15px 0;
        }
        .matrix-grid input {
            text-align: center;
            padding: 12px;
            font-size: 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 20px;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
            margin: 5px;
        }
        button:hover {
            background-color: #2980b9;
        }
        button.primary {
            background-color: #2ecc71;
        }
        button.primary:hover {
            background-color: #27ae60;
        }
        button.danger {
            background-color: #e74c3c;
        }
        button.danger:hover {
            background-color: #c0392b;
        }
        textarea {
            width: 100%;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            min-height: 100px;
            margin: 10px 0;
        }
        .status {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-weight: bold;
        }
        .valid {
            background-color: #d5f5e3;
            color: #27ae60;
        }
        .invalid {
            background-color: #fadbd8;
            color: #e74c3c;
        }
        .flex-row {
            display: flex;
            gap: 15px;
            margin: 15px 0;
        }
        .flex-row > div {
            flex: 1;
        }
        .round-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
        }
        .performance {
            font-family: monospace;
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Профессиональная реализация шифра Хилла</h1>
        
        <div class="section">
            <h2>Параметры шифрования</h2>
            <div class="flex-row">
                <div>
                    <label for="main-key">Основной ключ (минимум 16 символов):</label>
                    <input type="text" id="main-key" value="MySuperSecretKey123!">
                    <div id="key-status" class="status"></div>
                </div>
                <div>
                    <label for="rounds">Количество раундов (4-10):</label>
                    <select id="rounds" style="padding: 10px; width: 100%;">
                        <option value="4">4</option>
                        <option value="5" selected>5</option>
                        <option value="6">6</option>
                        <option value="7">7</option>
                        <option value="8">8</option>
                        <option value="9">9</option>
                        <option value="10">10</option>
                    </select>
                </div>
            </div>
            
            <div class="round-controls">
                <button id="generate-keys" class="primary">Сгенерировать ключи</button>
                <button id="check-params">Проверить параметры</button>
            </div>
            
            <div id="params-status" class="status"></div>
        </div>
        
        <div class="section">
            <h2>Ключевые матрицы (4×4)</h2>
            <div id="matrices-container"></div>
            <div id="matrix-status" class="status"></div>
        </div>
        
        <div class="section">
            <h2>Динамические S-Box (раундовые)</h2>
            <div id="sboxes-container"></div>
            <div id="sbox-status" class="status"></div>
        </div>
        
        <div class="section">
            <h2>Шифрование/дешифрование</h2>
            <label for="input-text">Исходный текст:</label>
            <textarea id="input-text" placeholder="Введите текст для шифрования..."></textarea>
            
            <div class="flex-row">
                <button id="encrypt-btn" class="primary">Зашифровать (AES-256)</button>
                <button id="encrypt-hill-btn" class="primary">Зашифровать (Хилл)</button>
                <button id="decrypt-hill-btn">Расшифровать (Хилл)</button>
            </div>
            
            <label for="output-text">Результат:</label>
            <textarea id="output-text" readonly></textarea>
            
            <div class="performance" id="performance"></div>
        </div>
    </div>

    <script>
        // ======================
        // КОНСТАНТЫ И НАСТРОЙКИ
        // ======================
        const BLOCK_SIZE = 4; // Размер блока 4x4
        const MODULUS = 251; // Простое число для модуля (больше 256)
        
        // ======================
        // ОСНОВНЫЕ ФУНКЦИИ
        // ======================
        
        // Хеширование ключа с помощью PBKDF2
        async function deriveKey(masterKey, salt, iterations = 100000) {
            const encoder = new TextEncoder();
            const keyMaterial = await window.crypto.subtle.importKey(
                'raw',
                encoder.encode(masterKey),
                { name: 'PBKDF2' },
                false,
                ['deriveBits']
            );
            
            const derivedBits = await window.crypto.subtle.deriveBits(
                {
                    name: 'PBKDF2',
                    salt: encoder.encode(salt),
                    iterations: iterations,
                    hash: 'SHA-256'
                },
                keyMaterial,
                256
            );
            
            return new Uint8Array(derivedBits);
        }
        
        // Генерация матрицы из ключа
        async function generateMatrixFromKey(key, round) {
            const hash = await deriveKey(key, `matrix-round-${round}`);
            const matrix = [];
            
            for (let i = 0; i < BLOCK_SIZE; i++) {
                const row = [];
                for (let j = 0; j < BLOCK_SIZE; j++) {
                    const index = (i * BLOCK_SIZE + j) % hash.length;
                    row.push(hash[index] % MODULUS);
                }
                matrix.push(row);
            }
            
            // Проверка на обратимость
            if (!isMatrixInvertible(matrix)) {
                // Если матрица необратима, модифицируем ее
                matrix[0][0] = (matrix[0][0] + 1) % MODULUS;
                return generateMatrixFromKey(key + "1", round);
            }
            
            return matrix;
        }
        
        // Генерация S-Box из ключа
        async function generateSBoxFromKey(key, round) {
            const hash = await deriveKey(key, `sbox-round-${round}`);
            const sbox = Array.from({ length: 256 }, (_, i) => i);
            
            // Алгоритом Фишера-Йетса
            let j = 0;
            for (let i = 0; i < 256; i++) {
                j = (j + sbox[i] + hash[i % hash.length]) % 256;
                [sbox[i], sbox[j]] = [sbox[j], sbox[i]];
            }
            
            return sbox;
        }
        
        // Проверка обратимости матрицы
        function isMatrixInvertible(matrix) {
            try {
                inverseMatrix(matrix);
                return true;
            } catch {
                return false;
            }
        }
        
        // Обратная матрица по модулю
        function inverseMatrix(matrix) {
            const n = matrix.length;
            const augmented = matrix.map((row, i) => 
                [...row, ...Array(n).fill(0).map((_, j) => i === j ? 1 : 0)]
            );
            
            // Прямой ход метода Гаусса
            for (let i = 0; i < n; i++) {
                // Поиск строки с максимальным элементом
                let maxRow = i;
                for (let j = i + 1; j < n; j++) {
                    if (augmented[j][i] > augmented[maxRow][i]) {
                        maxRow = j;
                    }
                }
                
                // Перестановка строк
                [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];
                
                // Нормализация текущей строки
                const inv = modInverse(augmented[i][i], MODULUS);
                if (inv === null) throw new Error("Матрица необратима");
                
                for (let j = 0; j < 2 * n; j++) {
                    augmented[i][j] = (augmented[i][j] * inv) % MODULUS;
                }
                
                // Вычитание текущей строки из других строк
                for (let k = 0; k < n; k++) {
                    if (k !== i && augmented[k][i] !== 0) {
                        const factor = augmented[k][i];
                        for (let j = 0; j < 2 * n; j++) {
                            augmented[k][j] = (augmented[k][j] - factor * augmented[i][j]) % MODULUS;
                            if (augmented[k][j] < 0) augmented[k][j] += MODULUS;
                        }
                    }
                }
            }
            
            // Извлечение обратной матрицы
            return augmented.map(row => row.slice(n, 2 * n));
        }
        
        // Обратный элемент в поле
        function modInverse(a, m) {
            a = ((a % m) + m) % m;
            for (let x = 1; x < m; x++) {
                if ((a * x) % m === 1) {
                    return x;
                }
            }
            return null;
        }
        
        // Настоящее матричное умножение
        function matrixMultiply(a, b) {
            const result = [];
            for (let i = 0; i < BLOCK_SIZE; i++) {
                result[i] = [];
                for (let j = 0; j < BLOCK_SIZE; j++) {
                    let sum = 0;
                    for (let k = 0; k < BLOCK_SIZE; k++) {
                        sum += a[i][k] * b[k][j];
                    }
                    result[i][j] = sum % MODULUS;
                }
            }
            return result;
        }
        
        // Преобразование текста в числовые блоки
        function textToBlocks(text) {
            const encoder = new TextEncoder();
            const bytes = encoder.encode(text);
            const blocks = [];
            
            for (let i = 0; i < bytes.length; i += BLOCK_SIZE * BLOCK_SIZE) {
                const block = [];
                for (let j = 0; j < BLOCK_SIZE; j++) {
                    const row = [];
                    for (let k = 0; k < BLOCK_SIZE; k++) {
                        const index = i + j * BLOCK_SIZE + k;
                        row.push(index < bytes.length ? bytes[index] : 0);
                    }
                    block.push(row);
                }
                blocks.push(block);
            }
            
            return blocks;
        }
        
        // Преобразование блоков в текст
        function blocksToText(blocks) {
            const bytes = [];
            for (const block of blocks) {
                for (let i = 0; i < BLOCK_SIZE; i++) {
                    for (let j = 0; j < BLOCK_SIZE; j++) {
                        if (block[i][j] !== 0) {
                            bytes.push(block[i][j]);
                        }
                    }
                }
            }
            
            // Удаление дополнения
            let padEnd = bytes.length;
            while (padEnd > 0 && bytes[padEnd - 1] === 0) {
                padEnd--;
            }
            
            const decoder = new TextDecoder();
            return decoder.decode(new Uint8Array(bytes.slice(0, padEnd)));
        }
        
        // Применение S-Box к блоку
        function applySBox(block, sbox) {
            return block.map(row => 
                row.map(val => sbox[val])
            );
        }
        
        // Основная функция шифрования
        async function hillEncrypt(text, matrices, sboxes) {
            const blocks = textToBlocks(text);
            const rounds = matrices.length;
            
            for (let i = 0; i < blocks.length; i++) {
                for (let r = 0; r < rounds; r++) {
                    // Подстановка
                    blocks[i] = applySBox(blocks[i], sboxes[r]);
                    
                    // Матричное умножение
                    blocks[i] = matrixMultiply(matrices[r], blocks[i]);
                    
                    // Добавление раундовой константы
                    for (let j = 0; j < BLOCK_SIZE; j++) {
                        for (let k = 0; k < BLOCK_SIZE; k++) {
                            blocks[i][j][k] = (blocks[i][j][k] + (r * BLOCK_SIZE + j + k)) % MODULUS;
                        }
                    }
                }
            }
            
            return blocksToText(blocks);
        }
        
        // Основная функция дешифрования
        async function hillDecrypt(text, matrices, sboxes) {
            const blocks = textToBlocks(text);
            const rounds = matrices.length;
            const inverseMatrices = matrices.map(m => inverseMatrix(m)).reverse();
            const inverseSboxes = sboxes.map(s => {
                const inv = new Array(256);
                for (let i = 0; i < 256; i++) inv[s[i]] = i;
                return inv;
            }).reverse();
            
            for (let i = 0; i < blocks.length; i++) {
                for (let r = 0; r < rounds; r++) {
                    // Удаление раундовой константы
                    const round = rounds - 1 - r;
                    for (let j = 0; j < BLOCK_SIZE; j++) {
                        for (let k = 0; k < BLOCK_SIZE; k++) {
                            blocks[i][j][k] = (blocks[i][j][k] - (round * BLOCK_SIZE + j + k)) % MODULUS;
                            if (blocks[i][j][k] < 0) blocks[i][j][k] += MODULUS;
                        }
                    }
                    
                    // Обратное матричное умножение
                    blocks[i] = matrixMultiply(inverseMatrices[r], blocks[i]);
                    
                    // Обратная подстановка
                    blocks[i] = applySBox(blocks[i], inverseSboxes[r]);
                }
            }
            
            return blocksToText(blocks);
        }
        
        // ======================
        // ИНТЕРФЕЙС И ВЗАИМОДЕЙСТВИЕ
        // ======================
        
        let currentMatrices = [];
        let currentSBoxes = [];
        
        // Инициализация интерфейса
        function initUI() {
            const rounds = parseInt(document.getElementById('rounds').value);
            renderMatrixInputs(rounds);
            renderSBoxInputs(rounds);
        }
        
        // Отрисовка полей для матриц
        function renderMatrixInputs(rounds) {
            const container = document.getElementById('matrices-container');
            container.innerHTML = '';
            
            for (let r = 0; r < rounds; r++) {
                const roundDiv = document.createElement('div');
                roundDiv.className = 'section';
                roundDiv.innerHTML = `<h3>Матрица раунда ${r + 1}</h3>`;
                
                const grid = document.createElement('div');
                grid.className = 'matrix-grid';
                
                for (let i = 0; i < BLOCK_SIZE; i++) {
                    for (let j = 0; j < BLOCK_SIZE; j++) {
                        const input = document.createElement('input');
                        input.type = 'number';
                        input.id = `matrix-${r}-${i}-${j}`;
                        input.value = '0';
                        input.readOnly = true;
                        grid.appendChild(input);
                    }
                }
                
                roundDiv.appendChild(grid);
                container.appendChild(roundDiv);
            }
        }
        
        // Отрисовка полей для S-Box
        function renderSBoxInputs(rounds) {
            const container = document.getElementById('sboxes-container');
            container.innerHTML = '';
            
            for (let r = 0; r < rounds; r++) {
                const roundDiv = document.createElement('div');
                roundDiv.className = 'section';
                roundDiv.innerHTML = `<h3>S-Box раунда ${r + 1}</h3>`;
                
                const textarea = document.createElement('textarea');
                textarea.id = `sbox-${r}`;
                textarea.readOnly = true;
                textarea.rows = 2;
                roundDiv.appendChild(textarea);
                
                container.appendChild(roundDiv);
            }
        }
        
        // Обновление UI матрицами
        function updateMatricesUI(matrices) {
            for (let r = 0; r < matrices.length; r++) {
                for (let i = 0; i < BLOCK_SIZE; i++) {
                    for (let j = 0; j < BLOCK_SIZE; j++) {
                        const input = document.getElementById(`matrix-${r}-${i}-${j}`);
                        if (input) input.value = matrices[r][i][j];
                    }
                }
            }
        }
        
        // Обновление UI S-Box
        function updateSBoxesUI(sboxes) {
            for (let r = 0; r < sboxes.length; r++) {
                const textarea = document.getElementById(`sbox-${r}`);
                if (textarea) {
                    textarea.value = sboxes[r].slice(0, 16).join(', ') + '...';
                    textarea.title = sboxes[r].join(', ');
                }
            }
        }
        
        // Генерация ключей
        async function generateKeys() {
            const mainKey = document.getElementById('main-key').value;
            const rounds = parseInt(document.getElementById('rounds').value);
            
            if (mainKey.length < 16) {
                document.getElementById('key-status').textContent = 'Ошибка: ключ должен быть не менее 16 символов';
                document.getElementById('key-status').className = 'status invalid';
                return;
            }
            
            document.getElementById('key-status').textContent = 'Генерация ключей...';
            document.getElementById('key-status').className = 'status';
            
            try {
                const startTime = performance.now();
                
                // Генерация матриц и S-Box для каждого раунда
                currentMatrices = [];
                currentSBoxes = [];
                
                for (let r = 0; r < rounds; r++) {
                    const matrix = await generateMatrixFromKey(mainKey + r, r);
                    const sbox = await generateSBoxFromKey(mainKey + r + 'sbox', r);
                    
                    currentMatrices.push(matrix);
                    currentSBoxes.push(sbox);
                }
                
                updateMatricesUI(currentMatrices);
                updateSBoxesUI(currentSBoxes);
                
                const endTime = performance.now();
                document.getElementById('key-status').textContent = `Ключи успешно сгенерированы за ${(endTime - startTime).toFixed(2)} мс`;
                document.getElementById('key-status').className = 'status valid';
                
                document.getElementById('params-status').textContent = 
                    `Параметры: ${rounds} раундов, размер блока ${BLOCK_SIZE}x${BLOCK_SIZE}, модуль ${MODULUS}`;
                document.getElementById('params-status').className = 'status valid';
                
            } catch (error) {
                document.getElementById('key-status').textContent = 'Ошибка: ' + error.message;
                document.getElementById('key-status').className = 'status invalid';
                console.error(error);
            }
        }
        
        // Проверка параметров
        async function checkParameters() {
            if (currentMatrices.length === 0 || currentSBoxes.length === 0) {
                document.getElementById('matrix-status').textContent = 'Ошибка: ключи не сгенерированы';
                document.getElementById('matrix-status').className = 'status invalid';
                return;
            }
            
            try {
                // Проверка всех матриц на обратимость
                for (let i = 0; i < currentMatrices.length; i++) {
                    inverseMatrix(currentMatrices[i]);
                }
                
                document.getElementById('matrix-status').textContent = 
                    `Все ${currentMatrices.length} матриц обратимы по модулю ${MODULUS}`;
                document.getElementById('matrix-status').className = 'status valid';
                
                // Проверка S-Box
                for (let i = 0; i < currentSBoxes.length; i++) {
                    const sbox = currentSBoxes[i];
                    const unique = new Set(sbox);
                    if (unique.size !== 256) {
                        throw new Error(`S-Box раунда ${i+1} содержит повторяющиеся значения`);
                    }
                }
                
                document.getElementById('sbox-status').textContent = 
                    `Все ${currentSBoxes.length} S-Box валидны (биективные отображения)`;
                document.getElementById('sbox-status').className = 'status valid';
                
            } catch (error) {
                document.getElementById('matrix-status').textContent = 'Ошибка: ' + error.message;
                document.getElementById('matrix-status').className = 'status invalid';
                console.error(error);
            }
        }
        
        // Шифрование с помощью AES (для сравнения)
        async function encryptAES() {
            const text = document.getElementById('input-text').value;
            if (!text) {
                document.getElementById('output-text').value = 'Введите текст для шифрования';
                return;
            }
            
            try {
                const startTime = performance.now();
                const encoder = new TextEncoder();
                const data = encoder.encode(text);
                
                const key = await window.crypto.subtle.generateKey(
                    { name: 'AES-CBC', length: 256 },
                    true,
                    ['encrypt', 'decrypt']
                );
                
                const iv = window.crypto.getRandomValues(new Uint8Array(16));
                const encrypted = await window.crypto.subtle.encrypt(
                    { name: 'AES-CBC', iv },
                    key,
                    data
                );
                
                const endTime = performance.now();
                
                // Преобразование в hex-строку
                const hex = Array.from(new Uint8Array(encrypted))
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');
                
                document.getElementById('output-text').value = hex;
                document.getElementById('performance').textContent = 
                    `AES-256 шифрование: ${data.length} байт → ${encrypted.byteLength} байт за ${(endTime - startTime).toFixed(2)} мс`;
                
            } catch (error) {
                document.getElementById('output-text').value = 'Ошибка: ' + error.message;
                console.error(error);
            }
        }
        
        // Шифрование с помощью Хилла
        async function encryptHill() {
            const text = document.getElementById('input-text').value;
            if (!text) {
                document.getElementById('output-text').value = 'Введите текст для шифрования';
                return;
            }
            
            if (currentMatrices.length === 0) {
                document.getElementById('output-text').value = 'Сначала сгенерируйте ключи';
                return;
            }
            
            try {
                const startTime = performance.now();
                const encrypted = await hillEncrypt(text, currentMatrices, currentSBoxes);
                const endTime = performance.now();
                
                // Преобразование в base64
                const encoder = new TextEncoder();
                const bytes = encoder.encode(encrypted);
                const base64 = btoa(String.fromCharCode(...bytes));
                
                document.getElementById('output-text').value = base64;
                document.getElementById('performance').textContent = 
                    `Hill шифрование: ${text.length} символов → ${base64.length} байт base64 за ${(endTime - startTime).toFixed(2)} мс`;
                
            } catch (error) {
                document.getElementById('output-text').value = 'Ошибка: ' + error.message;
                console.error(error);
            }
        }
        
        // Дешифрование с помощью Хилла
        async function decryptHill() {
            const text = document.getElementById('input-text').value;
            if (!text) {
                document.getElementById('output-text').value = 'Введите текст для дешифрования';
                return;
            }
            
            if (currentMatrices.length === 0) {
                document.getElementById('output-text').value = 'Сначала сгенерируйте ключи';
                return;
            }
            
            try {
                const startTime = performance.now();
                
                // Преобразование из base64
                const bytes = Uint8Array.from(atob(text), c => c.charCodeAt(0));
                const decoder = new TextDecoder();
                const encryptedText = decoder.decode(bytes);
                
                const decrypted = await hillDecrypt(encryptedText, currentMatrices, currentSBoxes);
                const endTime = performance.now();
                
                document.getElementById('output-text').value = decrypted;
                document.getElementById('performance').textContent = 
                    `Hill дешифрование: ${text.length} байт base64 → ${decrypted.length} символов за ${(endTime - startTime).toFixed(2)} мс`;
                
            } catch (error) {
                document.getElementById('output-text').value = 'Ошибка: ' + error.message;
                console.error(error);
            }
        }
        
        // Инициализация при загрузке
        document.addEventListener('DOMContentLoaded', () => {
            initUI();
            
            document.getElementById('generate-keys').addEventListener('click', generateKeys);
            document.getElementById('check-params').addEventListener('click', checkParameters);
            document.getElementById('encrypt-btn').addEventListener('click', encryptAES);
            document.getElementById('encrypt-hill-btn').addEventListener('click', encryptHill);
            document.getElementById('decrypt-hill-btn').addEventListener('click', decryptHill);
            
            document.getElementById('rounds').addEventListener('change', initUI);
        });
    </script>
</body>
</html>
