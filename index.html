<!DOCTYPE html>
<html>
<head>
    <title>Шифр Хилла с S-Box</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .container { display: flex; flex-direction: column; gap: 20px; }
        .form-group { display: flex; flex-direction: column; gap: 5px; }
        textarea, input, select { padding: 8px; font-size: 16px; }
        button { padding: 10px; background-color: #4CAF50; color: white; border: none; cursor: pointer; }
        .results { display: flex; gap: 20px; }
        .result-box { flex: 1; border: 1px solid #ddd; padding: 15px; border-radius: 5px; }
        .plots { display: flex; gap: 20px; margin-top: 20px; }
        .plot { flex: 1; }
        img { max-width: 100%; }
        .error { color: red; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/numpy@1.0.0/dist/numpy.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.7.0/math.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>Шифр Хилла с S-Box и многораундовостью</h1>
        
        <form id="cipherForm">
            <div class="form-group">
                <label for="text">Текст:</label>
                <textarea id="text" name="text" rows="4" required></textarea>
            </div>
            
            <div class="form-group">
                <label for="key">Ключевое слово:</label>
                <input type="text" id="key" name="key" value="HILL" required>
            </div>
            
            <div class="form-group">
                <label for="rounds">Количество раундов:</label>
                <select id="rounds" name="rounds">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3" selected>3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="block_size">Размер блока:</label>
                <select id="block_size" name="block_size">
                    <option value="2">2x2</option>
                    <option value="3" selected>3x3</option>
                </select>
            </div>
            
            <button type="button" onclick="process('encrypt')">Зашифровать</button>
            <button type="button" onclick="process('decrypt')">Дешифровать</button>
        </form>
        
        <div id="error" class="error"></div>
        
        <div id="results" class="results" style="display: none;">
            <div class="result-box">
                <h3>Результат:</h3>
                <p id="resultText"></p>
            </div>
        </div>
        
        <div class="plots">
            <div class="plot" id="originalPlot"></div>
            <div class="plot" id="resultPlot"></div>
        </div>
    </div>

    <script>
        // Алфавит и S-Box
        const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        const ALPHABET_SIZE = ALPHABET.length;
        
        const S_BOX = {
            0: 5, 1: 14, 2: 7, 3: 2, 4: 11, 5: 8, 6: 13, 7: 4,
            8: 10, 9: 15, 10: 3, 11: 0, 12: 9, 13: 6, 14: 12, 15: 1,
            16: 18, 17: 25, 18: 20, 19: 17, 20: 22, 21: 19, 22: 24, 23: 16,
            24: 21, 25: 23
        };
        
        const INVERSE_S_BOX = {};
        for (const key in S_BOX) {
            INVERSE_S_BOX[S_BOX[key]] = parseInt(key);
        }
        
        // Преобразование текста в числовую матрицу
        function textToMatrix(text, blockSize) {
            text = text.toUpperCase().replace(/ /g, '');
            // Дополнение текста, если необходимо
            const padding = (blockSize - text.length % blockSize) % blockSize;
            text += 'X'.repeat(padding);
            
            const nums = [];
            for (const c of text) {
                nums.push(ALPHABET.indexOf(c));
            }
            
            // Преобразование в матрицу
            const matrix = [];
            const numBlocks = nums.length / blockSize;
            
            for (let i = 0; i < blockSize; i++) {
                const row = [];
                for (let j = 0; j < numBlocks; j++) {
                    row.push(nums[j * blockSize + i]);
                }
                matrix.push(row);
            }
            
            return matrix;
        }
        
        // Преобразование матрицы обратно в текст
        function matrixToText(matrix) {
            const blockSize = matrix.length;
            const numBlocks = matrix[0].length;
            const nums = [];
            
            for (let j = 0; j < numBlocks; j++) {
                for (let i = 0; i < blockSize; i++) {
                    nums.push(matrix[i][j] % ALPHABET_SIZE);
                }
            }
            
            let text = '';
            for (const num of nums) {
                text += ALPHABET[num];
            }
            
            return text;
        }
        
        // Функция для вычисления НОД
        function gcd(a, b) {
            a = Math.abs(a);
            b = Math.abs(b);
            
            while (b) {
                const t = b;
                b = a % b;
                a = t;
            }
            return a;
        }
        
        // Функция для вычисления обратного числа по модулю
        function modInverse(a, m) {
            a = (a % m + m) % m;
            for (let x = 1; x < m; x++) {
                if ((a * x) % m === 1) {
                    return x;
                }
            }
            return 1;
        }
        
        // Функция для вычисления определителя матрицы
        function matrixDeterminant(matrix) {
            if (matrix.length === 2) {
                return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];
            }
            
            let det = 0;
            for (let i = 0; i < matrix.length; i++) {
                const minor = [];
                for (let j = 1; j < matrix.length; j++) {
                    minor.push(matrix[j].filter((_, k) => k !== i));
                }
                det += matrix[0][i] * (i % 2 === 0 ? 1 : -1) * matrixDeterminant(minor);
            }
            return det;
        }
        
        // Функция для вычисления обратной матрицы по модулю
        function modInverseMatrix(matrix, mod) {
            const size = matrix.length;
            const det = matrixDeterminant(matrix);
            const detInv = modInverse(det, mod);
            
            if (gcd(det, mod) !== 1) {
                throw new Error("Ключевая матрица не обратима по модулю алфавита. Выберите другое ключевое слово.");
            }
            
            // Матрица миноров
            const minorMatrix = [];
            for (let i = 0; i < size; i++) {
                const minorRow = [];
                for (let j = 0; j < size; j++) {
                    const subMatrix = [];
                    for (let k = 0; k < size; k++) {
                        if (k === i) continue;
                        const subRow = [];
                        for (let l = 0; l < size; l++) {
                            if (l === j) continue;
                            subRow.push(matrix[k][l]);
                        }
                        subMatrix.push(subRow);
                    }
                    const minor = matrixDeterminant(subMatrix);
                    minorRow.push((((i + j) % 2 === 0 ? 1 : -1) * minor);
                }
                minorMatrix.push(minorRow);
            }
            
            // Транспонирование матрицы миноров (матрица алгебраических дополнений)
            const adjugate = [];
            for (let i = 0; i < size; i++) {
                adjugate.push([]);
                for (let j = 0; j < size; j++) {
                    adjugate[i].push(minorMatrix[j][i]);
                }
            }
            
            // Умножение на обратный определитель по модулю
            const inverse = [];
            for (let i = 0; i < size; i++) {
                inverse.push([]);
                for (let j = 0; j < size; j++) {
                    inverse[i].push((adjugate[i][j] * detInv) % mod);
                    // Убедимся, что результат положительный
                    if (inverse[i][j] < 0) {
                        inverse[i][j] += mod;
                    }
                }
            }
            
            return inverse;
        }
        
        // Генерация ключевой матрицы
        function generateKeyMatrix(keyWord, blockSize) {
            keyWord = keyWord.toUpperCase().replace(/ /g, '');
            const keyNums = [];
            for (const c of keyWord) {
                keyNums.push(ALPHABET.indexOf(c));
            }
            
            // Дополняем ключ, если он слишком короткий
            while (keyNums.length < blockSize * blockSize) {
                for (let i = 0; i < blockSize * blockSize - keyNums.length; i++) {
                    keyNums.push(keyNums.length % ALPHABET_SIZE);
                }
            }
            
            // Формируем матрицу
            const keyMatrix = [];
            for (let i = 0; i < blockSize; i++) {
                const row = [];
                for (let j = 0; j < blockSize; j++) {
                    row.push(keyNums[i * blockSize + j]);
                }
                keyMatrix.push(row);
            }
            
            // Проверяем, что матрица обратима
            const det = matrixDeterminant(keyMatrix);
            if (gcd(det, ALPHABET_SIZE) !== 1) {
                throw new Error("Ключевая матрица не обратима по модулю алфавита. Выберите другое ключевое слово.");
            }
            
            return keyMatrix;
        }
        
        // Применение S-Box
        function applySbox(matrix) {
            const result = [];
            for (let i = 0; i < matrix.length; i++) {
                result.push([]);
                for (let j = 0; j < matrix[i].length; j++) {
                    result[i].push(S_BOX[matrix[i][j]]);
                }
            }
            return result;
        }
        
        // Применение обратного S-Box
        function applyInverseSbox(matrix) {
            const result = [];
            for (let i = 0; i < matrix.length; i++) {
                result.push([]);
                for (let j = 0; j < matrix[i].length; j++) {
                    result[i].push(INVERSE_S_BOX[matrix[i][j]]);
                }
            }
            return result;
        }
        
        // Умножение матриц по модулю
        function matrixMultiply(a, b, mod) {
            const result = [];
            for (let i = 0; i < a.length; i++) {
                result.push([]);
                for (let j = 0; j < b[0].length; j++) {
                    let sum = 0;
                    for (let k = 0; k < a[0].length; k++) {
                        sum += a[i][k] * b[k][j];
                    }
                    result[i].push(sum % mod);
                }
            }
            return result;
        }
        
        // Шифрование
        function hillEncrypt(plaintext, keyWord, rounds, blockSize) {
            const keyMatrix = generateKeyMatrix(keyWord, blockSize);
            const invKeyMatrix = modInverseMatrix(keyMatrix, ALPHABET_SIZE);
            
            let matrix = textToMatrix(plaintext, blockSize);
            
            for (let i = 0; i < rounds; i++) {
                // Линейное преобразование
                matrix = matrixMultiply(keyMatrix, matrix, ALPHABET_SIZE);
                // Нелинейное преобразование
                matrix = applySbox(matrix);
            }
            
            return matrixToText(matrix);
        }
        
        // Дешифрование
        function hillDecrypt(ciphertext, keyWord, rounds, blockSize) {
            const keyMatrix = generateKeyMatrix(keyWord, blockSize);
            const invKeyMatrix = modInverseMatrix(keyMatrix, ALPHABET_SIZE);
            
            let matrix = textToMatrix(ciphertext, blockSize);
            
            for (let i = 0; i < rounds; i++) {
                // Обратное нелинейное преобразование
                matrix = applyInverseSbox(matrix);
                // Линейное преобразование
                matrix = matrixMultiply(invKeyMatrix, matrix, ALPHABET_SIZE);
            }
            
            return matrixToText(matrix);
        }
        
        // Визуализация распределения букв
        function plotLetterDistribution(text, title, elementId) {
            text = text.toUpperCase();
            const letters = Array.from(text).filter(c => ALPHABET.includes(c));
            const counts = {};
            
            // Инициализация счетчиков
            for (const letter of ALPHABET) {
                counts[letter] = 0;
            }
            
            // Подсчет букв
            for (const letter of letters) {
                counts[letter]++;
            }
            
            // Подготовка данных для графика
            const xValues = [];
            const yValues = [];
            
            for (const letter in counts) {
                xValues.push(letter);
                yValues.push(counts[letter]);
            }
            
            // Создание графика
            const data = [{
                x: xValues,
                y: yValues,
                type: 'bar'
            }];
            
            const layout = {
                title: title,
                xaxis: { title: 'Буквы' },
                yaxis: { title: 'Частота' }
            };
            
            Plotly.newPlot(elementId, data, layout);
        }
        
        // Обработка формы
        function process(action) {
            const text = document.getElementById('text').value;
            const key = document.getElementById('key').value;
            const rounds = parseInt(document.getElementById('rounds').value);
            const blockSize = parseInt(document.getElementById('block_size').value);
            
            document.getElementById('error').textContent = '';
            document.getElementById('results').style.display = 'none';
            
            try {
                let result;
                if (action === 'encrypt') {
                    result = hillEncrypt(text, key, rounds, blockSize);
                } else {
                    result = hillDecrypt(text, key, rounds, blockSize);
                }
                
                document.getElementById('resultText').textContent = result;
                document.getElementById('results').style.display = 'flex';
                
                // Визуализация распределения букв
                plotLetterDistribution(text, "Исходный текст", "originalPlot");
                plotLetterDistribution(result, "Результат", "resultPlot");
                
            } catch (e) {
                document.getElementById('error').textContent = 'Ошибка: ' + e.message;
            }
        }
    </script>
</body>
</html>
