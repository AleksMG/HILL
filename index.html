<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Усиленный шифр Хилла с динамическими S-Box</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .section {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        textarea, input, button, select {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            box-sizing: border-box;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            padding: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        .matrix-input {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin: 10px 0;
        }
        .matrix-input input {
            text-align: center;
        }
        .result {
            background-color: #f9f9f9;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
            word-break: break-all;
        }
        .key-inputs {
            display: flex;
            gap: 10px;
        }
        .key-inputs > div {
            flex: 1;
        }
        .status {
            margin-top: 5px;
            font-size: 0.9em;
        }
        .valid {
            color: green;
        }
        .invalid {
            color: red;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Усиленный шифр Хилла с динамическими S-Box</h1>
        
        <div class="section">
            <h2>Ключевые параметры</h2>
            <div class="key-inputs">
                <div>
                    <label for="matrix-key">Ключевое слово для матрицы:</label>
                    <input type="text" id="matrix-key" value="SECRET">
                    <div id="matrix-key-status" class="status"></div>
                </div>
                <div>
                    <label for="sbox-key">Ключевое слово для S-Box:</label>
                    <input type="text" id="sbox-key" value="CRYPTO">
                    <div id="sbox-key-status" class="status"></div>
                </div>
            </div>
            <div>
                <label for="rounds">Количество раундов:</label>
                <select id="rounds">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3" selected>3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                </select>
            </div>
            <button id="generate-keys">Сгенерировать ключи</button>
        </div>
        
        <div class="section">
            <h2>Ключевая матрица</h2>
            <div class="matrix-input" id="matrix-container">
                <input type="number" id="m00" readonly>
                <input type="number" id="m01" readonly>
                <input type="number" id="m02" readonly>
                <input type="number" id="m10" readonly>
                <input type="number" id="m11" readonly>
                <input type="number" id="m12" readonly>
                <input type="number" id="m20" readonly>
                <input type="number" id="m21" readonly>
                <input type="number" id="m22" readonly>
            </div>
            <button id="check-matrix">Проверить обратимость матрицы</button>
            <div id="matrix-status" class="result"></div>
        </div>
        
        <div class="section">
            <h2>S-Box (подстановочная таблица)</h2>
            <input type="text" id="sbox-input" readonly>
            <div id="sbox-status" class="result"></div>
        </div>
        
        <div class="section">
            <h2>Шифрование/Дешифрование</h2>
            <textarea id="input-text" rows="4" placeholder="Введите текст для шифрования (только буквы A-Z)"></textarea>
            <button id="encrypt-btn">Зашифровать</button>
            <button id="decrypt-btn">Расшифровать</button>
            <div class="result" id="output-text"></div>
        </div>
    </div>

    <script>
        // Инициализация элементов
        const matrixKeyInput = document.getElementById('matrix-key');
        const sboxKeyInput = document.getElementById('sbox-key');
        const matrixKeyStatus = document.getElementById('matrix-key-status');
        const sboxKeyStatus = document.getElementById('sbox-key-status');
        const roundsSelect = document.getElementById('rounds');
        const generateKeysBtn = document.getElementById('generate-keys');
        const matrixInputs = document.querySelectorAll('.matrix-input input');
        const checkMatrixBtn = document.getElementById('check-matrix');
        const matrixStatus = document.getElementById('matrix-status');
        const sboxInput = document.getElementById('sbox-input');
        const sboxStatus = document.getElementById('sbox-status');
        const inputText = document.getElementById('input-text');
        const encryptBtn = document.getElementById('encrypt-btn');
        const decryptBtn = document.getElementById('decrypt-btn');
        const outputText = document.getElementById('output-text');
        
        // Проверка ключевого слова
        function validateKey(key, type) {
            const cleanKey = key.toUpperCase().replace(/[^A-Z]/g, '');
            if (cleanKey.length < 3) {
                return { valid: false, message: `Ключевое слово для ${type} должно содержать хотя бы 3 буквы` };
            }
            return { valid: true, key: cleanKey };
        }
        
        // Генерация матрицы из ключевого слова
        function generateMatrixFromKey(key) {
            const numbers = [];
            for (let i = 0; i < 9; i++) {
                const char = key[i % key.length];
                numbers.push(char.charCodeAt(0) - 65);
            }
            
            return [
                [numbers[0], numbers[1], numbers[2]],
                [numbers[3], numbers[4], numbers[5]],
                [numbers[6], numbers[7], numbers[8]]
            ];
        }
        
        // Генерация S-Box из ключевого слова
        function generateSBoxFromKey(key) {
            // Начальная последовательность
            let sbox = [];
            for (let i = 0; i < 26; i++) {
                sbox.push(i);
            }
            
            // Перемешивание с использованием ключа
            let shuffled = [];
            const keyNumbers = [];
            for (const char of key) {
                keyNumbers.push(char.charCodeAt(0) - 65);
            }
            
            let currentIndex = sbox.length;
            let keyIndex = 0;
            
            while (currentIndex > 0) {
                const randomPart = keyNumbers[keyIndex % keyNumbers.length];
                const randomIndex = (randomPart + keyIndex) % currentIndex;
                currentIndex--;
                
                // Меняем местами
                [sbox[currentIndex], sbox[randomIndex]] = [sbox[randomIndex], sbox[currentIndex]];
                
                keyIndex++;
            }
            
            return sbox;
        }
        
        // Обновление интерфейса с матрицей
        function updateMatrixUI(matrix) {
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    document.getElementById(`m${i}${j}`).value = matrix[i][j];
                }
            }
        }
        
        // Обновление интерфейса с S-Box
        function updateSBoxUI(sbox) {
            sboxInput.value = sbox.join(', ');
        }
        
        // Проверка и создание S-Box
        function validateSBox(sbox) {
            if (sbox.length !== 26) {
                sboxStatus.textContent = "Ошибка: S-Box должен содержать 26 значений";
                return null;
            }
            
            const unique = new Set(sbox);
            if (unique.size !== 26) {
                sboxStatus.textContent = "Ошибка: значения в S-Box должны быть уникальными";
                return null;
            }
            
            for (const val of sbox) {
                if (isNaN(val) || val < 0 || val > 25) {
                    sboxStatus.textContent = "Ошибка: значения в S-Box должны быть числами от 0 до 25";
                    return null;
                }
            }
            
            sboxStatus.textContent = "S-Box валиден";
            return sbox;
        }
        
        // Создание обратного S-Box
        function createInverseSBox(sbox) {
            const inverse = new Array(26);
            for (let i = 0; i < 26; i++) {
                inverse[sbox[i]] = i;
            }
            return inverse;
        }
        
        // Получение матрицы из ввода
        function getMatrix() {
            const matrix = [];
            for (let i = 0; i < 3; i++) {
                const row = [];
                for (let j = 0; j < 3; j++) {
                    const val = parseInt(document.getElementById(`m${i}${j}`).value);
                    row.push(val);
                }
                matrix.push(row);
            }
            return matrix;
        }
        
        // Проверка обратимости матрицы
        function isMatrixInvertible(matrix) {
            // Вычисляем определитель
            const a = matrix[0][0], b = matrix[0][1], c = matrix[0][2];
            const d = matrix[1][0], e = matrix[1][1], f = matrix[1][2];
            const g = matrix[2][0], h = matrix[2][1], i = matrix[2][2];
            
            const det = a*(e*i - f*h) - b*(d*i - f*g) + c*(d*h - e*g);
            
            // Матрица обратима по модулю 26, если det и 26 взаимно просты
            return gcd(det, 26) === 1;
        }
        
        // НОД (алгоритм Евклида)
        function gcd(a, b) {
            a = Math.abs(a);
            b = Math.abs(b);
            while (b) {
                const t = b;
                b = a % b;
                a = t;
            }
            return a;
        }
        
        // Обратная матрица по модулю 26
        function inverseMatrix(matrix) {
            const a = matrix[0][0], b = matrix[0][1], c = matrix[0][2];
            const d = matrix[1][0], e = matrix[1][1], f = matrix[1][2];
            const g = matrix[2][0], h = matrix[2][1], k = matrix[2][2];
            
            // Вычисляем определитель
            const det = a*(e*k - f*h) - b*(d*k - f*g) + c*(d*h - e*g);
            const detInv = modInverse(det, 26);
            
            // Матрица миноров
            const minor00 = (e*k - f*h) * detInv % 26;
            const minor01 = (d*k - f*g) * detInv % 26;
            const minor02 = (d*h - e*g) * detInv % 26;
            const minor10 = (b*k - c*h) * detInv % 26;
            const minor11 = (a*k - c*g) * detInv % 26;
            const minor12 = (a*h - b*g) * detInv % 26;
            const minor20 = (b*f - c*e) * detInv % 26;
            const minor21 = (a*f - c*d) * detInv % 26;
            const minor22 = (a*e - b*d) * detInv % 26;
            
            // Обратная матрица (транспонированная матрица алгебраических дополнений)
            return [
                [positiveMod(minor00, 26), positiveMod(-minor10, 26), positiveMod(minor20, 26)],
                [positiveMod(-minor01, 26), positiveMod(minor11, 26), positiveMod(-minor21, 26)],
                [positiveMod(minor02, 26), positiveMod(-minor12, 26), positiveMod(minor22, 26)]
            ];
        }
        
        // Обратный элемент в кольце вычетов
        function modInverse(a, m) {
            a = positiveMod(a, m);
            for (let x = 1; x < m; x++) {
                if ((a * x) % m === 1) {
                    return x;
                }
            }
            return 1;
        }
        
        // Положительный модуль
        function positiveMod(n, m) {
            return ((n % m) + m) % m;
        }
        
        // Преобразование текста в числа
        function textToNumbers(text) {
            return text.toUpperCase().replace(/[^A-Z]/g, '').split('').map(c => c.charCodeAt(0) - 65);
        }
        
        // Преобразование чисел в текст
        function numbersToText(numbers) {
            return numbers.map(n => String.fromCharCode(n + 65)).join('');
        }
        
        // Применение S-Box
        function applySBox(numbers, sbox) {
            return numbers.map(n => sbox[n]);
        }
        
        // Обратное применение S-Box
        function applyInverseSBox(numbers, inverseSbox) {
            return numbers.map(n => inverseSbox[n]);
        }
        
        // Шифрование блока
        function encryptBlock(block, matrix) {
            const result = [0, 0, 0];
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    result[i] += matrix[i][j] * block[j];
                }
                result[i] = positiveMod(result[i], 26);
            }
            return result;
        }
        
        // Дешифрование блока
        function decryptBlock(block, inverseMatrix) {
            return encryptBlock(block, inverseMatrix);
        }
        
        // Основная функция шифрования
        function encrypt() {
            const text = inputText.value;
            if (!text) {
                outputText.textContent = "Введите текст для шифрования";
                return;
            }
            
            const matrix = getMatrix();
            if (!isMatrixInvertible(matrix)) {
                outputText.textContent = "Ошибка: матрица необратима по модулю 26";
                return;
            }
            
            const sbox = validateSBox(sboxInput.value.split(',').map(x => parseInt(x.trim())));
            if (!sbox) return;
            
            const inverseSbox = createInverseSBox(sbox);
            const rounds = parseInt(roundsSelect.value);
            
            let numbers = textToNumbers(text);
            if (numbers.length === 0) {
                outputText.textContent = "Текст должен содержать буквы A-Z";
                return;
            }
            
            // Дополнение до кратного 3
            const paddingLength = (3 - (numbers.length % 3)) % 3;
            const paddedNumbers = [...numbers, ...Array(paddingLength).fill(23)]; // 23 = 'X'
            
            // Многократное шифрование (раунды)
            let processedNumbers = [...paddedNumbers];
            
            for (let round = 0; round < rounds; round++) {
                // Применение S-Box перед шифрованием (кроме последнего раунда)
                if (round > 0 || rounds === 1) {
                    processedNumbers = applySBox(processedNumbers, sbox);
                }
                
                // Разбиение на блоки и шифрование
                const encryptedBlocks = [];
                for (let i = 0; i < processedNumbers.length; i += 3) {
                    const block = processedNumbers.slice(i, i + 3);
                    const encryptedBlock = encryptBlock(block, matrix);
                    encryptedBlocks.push(...encryptedBlock);
                }
                
                processedNumbers = encryptedBlocks;
                
                // Применение обратного S-Box после шифрования (кроме последнего раунда)
                if (round < rounds - 1) {
                    processedNumbers = applyInverseSBox(processedNumbers, inverseSbox);
                }
            }
            
            outputText.textContent = numbersToText(processedNumbers);
        }
        
        // Основная функция дешифрования
        function decrypt() {
            const text = inputText.value;
            if (!text) {
                outputText.textContent = "Введите текст для дешифрования";
                return;
            }
            
            const matrix = getMatrix();
            if (!isMatrixInvertible(matrix)) {
                outputText.textContent = "Ошибка: матрица необратима по модулю 26";
                return;
            }
            
            const inverseMat = inverseMatrix(matrix);
            const sbox = validateSBox(sboxInput.value.split(',').map(x => parseInt(x.trim())));
            if (!sbox) return;
            
            const inverseSbox = createInverseSBox(sbox);
            const rounds = parseInt(roundsSelect.value);
            
            let numbers = textToNumbers(text);
            if (numbers.length === 0 || numbers.length % 3 !== 0) {
                outputText.textContent = "Некорректная длина зашифрованного текста";
                return;
            }
            
            // Многократное дешифрование (раунды в обратном порядке)
            let processedNumbers = [...numbers];
            
            for (let round = rounds - 1; round >= 0; round--) {
                // Применение S-Box перед дешифрованием (кроме первого раунда)
                if (round < rounds - 1) {
                    processedNumbers = applySBox(processedNumbers, sbox);
                }
                
                // Разбиение на блоки и дешифрование
                const decryptedBlocks = [];
                for (let i = 0; i < processedNumbers.length; i += 3) {
                    const block = processedNumbers.slice(i, i + 3);
                    const decryptedBlock = decryptBlock(block, inverseMat);
                    decryptedBlocks.push(...decryptedBlock);
                }
                
                processedNumbers = decryptedBlocks;
                
                // Применение обратного S-Box после дешифрования (кроме первого раунда)
                if (round > 0) {
                    processedNumbers = applyInverseSBox(processedNumbers, inverseSbox);
                }
            }
            
            // Удаление дополнения (если было)
            let padding = 0;
            if (processedNumbers.length > 0) {
                const lastChar = processedNumbers[processedNumbers.length - 1];
                if (lastChar === 23) { // 'X'
                    padding = 1;
                    // Проверяем, не было ли нескольких 'X' в конце
                    for (let i = processedNumbers.length - 2; i >= 0 && processedNumbers[i] === 23; i--) {
                        padding++;
                    }
                }
            }
            const finalNumbers = processedNumbers.slice(0, processedNumbers.length - padding);
            
            outputText.textContent = numbersToText(finalNumbers);
        }
        
        // Генерация ключей
        function generateKeys() {
            // Проверка ключа матрицы
            const matrixKeyResult = validateKey(matrixKeyInput.value, 'матрицы');
            if (!matrixKeyResult.valid) {
                matrixKeyStatus.textContent = matrixKeyResult.message;
                matrixKeyStatus.className = 'status invalid';
                return;
            }
            matrixKeyStatus.textContent = "Ключевое слово для матрицы валидно";
            matrixKeyStatus.className = 'status valid';
            
            // Проверка ключа S-Box
            const sboxKeyResult = validateKey(sboxKeyInput.value, 'S-Box');
            if (!sboxKeyResult.valid) {
                sboxKeyStatus.textContent = sboxKeyResult.message;
                sboxKeyStatus.className = 'status invalid';
                return;
            }
            sboxKeyStatus.textContent = "Ключевое слово для S-Box валидно";
            sboxKeyStatus.className = 'status valid';
            
            // Генерация матрицы
            const matrix = generateMatrixFromKey(matrixKeyResult.key);
            updateMatrixUI(matrix);
            
            // Проверка обратимости матрицы
            if (!isMatrixInvertible(matrix)) {
                matrixStatus.textContent = "Предупреждение: сгенерированная матрица необратима по модулю 26. Попробуйте другое ключевое слово.";
                matrixStatus.style.color = "red";
            } else {
                matrixStatus.textContent = "Сгенерированная матрица обратима по модулю 26";
                matrixStatus.style.color = "green";
            }
            
            // Генерация S-Box
            const sbox = generateSBoxFromKey(sboxKeyResult.key);
            updateSBoxUI(sbox);
            validateSBox(sbox);
        }
        
        // Обработчики событий
        checkMatrixBtn.addEventListener('click', () => {
            const matrix = getMatrix();
            if (isMatrixInvertible(matrix)) {
                matrixStatus.textContent = "Матрица обратима по модулю 26";
                matrixStatus.style.color = "green";
            } else {
                matrixStatus.textContent = "Матрица необратима по модулю 26";
                matrixStatus.style.color = "red";
            }
        });
        
        generateKeysBtn.addEventListener('click', generateKeys);
        encryptBtn.addEventListener('click', encrypt);
        decryptBtn.addEventListener('click', decrypt);
        
        // Инициализация при загрузке
        document.addEventListener('DOMContentLoaded', () => {
            generateKeys();
        });
    </script>
</body>
</html>
