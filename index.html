<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChaCha20 с пользовательским алфавитом</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        textarea, input, button {
            width: 100%;
            margin-bottom: 10px;
            padding: 8px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            padding: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .result {
            padding: 10px;
            border: 1px solid #ddd;
            min-height: 50px;
        }
    </style>
</head>
<body>
    <h1>ChaCha20 с пользовательским алфавитом</h1>
    
    <div class="container">
        <div>
            <label for="alphabet">Алфавит (символы без пробелов):</label>
            <input type="text" id="alphabet" value="ABCDEFGHIJKLMNOPQRSTUVWXYZ" placeholder="Введите алфавит (например, ABCDEFGHIJKLMNOPQRSTUVWXYZ)">
        </div>
        
        <div>
            <label for="key">Ключ (любой текст):</label>
            <input type="text" id="key" value="секретныйключ" placeholder="Введите ключ">
        </div>
        
        <div>
            <label for="nonce">Nonce (уникальное значение):</label>
            <input type="text" id="nonce" value="уникальныйнонс" placeholder="Введите nonce">
        </div>
        
        <div>
            <label for="counter">Счетчик (число):</label>
            <input type="number" id="counter" value="1" min="0">
        </div>
        
        <div>
            <label for="message">Сообщение для шифрования (только символы из алфавита):</label>
            <textarea id="message" rows="4" placeholder="Введите сообщение для шифрования"></textarea>
        </div>
        
        <button onclick="encrypt()">Зашифровать</button>
        
        <div>
            <label for="ciphertext">Шифротекст:</label>
            <textarea id="ciphertext" rows="4" placeholder="Шифротекст появится здесь"></textarea>
        </div>
        
        <button onclick="decrypt()">Расшифровать</button>
        
        <div>
            <label>Результат:</label>
            <div id="result" class="result"></div>
        </div>
    </div>

    <script>
        // Функции для работы с ChaCha20
        function quarterRound(state, a, b, c, d) {
            state[a] += state[b]; state[d] = rotateLeft(state[d] ^ state[a], 16);
            state[c] += state[d]; state[b] = rotateLeft(state[b] ^ state[c], 12);
            state[a] += state[b]; state[d] = rotateLeft(state[d] ^ state[a], 8);
            state[c] += state[d]; state[b] = rotateLeft(state[b] ^ state[c], 7);
        }

        function rotateLeft(value, amount) {
            return (value << amount) | (value >>> (32 - amount));
        }

        function chacha20Block(key, counter, nonce) {
            // Константы
            const constants = [0x61707865, 0x3320646e, 0x79622d32, 0x6b206574];
            
            // Преобразуем ключ, счетчик и нонс в массив 32-битных слов
            const keyWords = [];
            for (let i = 0; i < 8; i++) {
                keyWords.push(
                    (key.charCodeAt(i*4+3) << 24) |
                    (key.charCodeAt(i*4+2) << 16) |
                    (key.charCodeAt(i*4+1) << 8) |
                    key.charCodeAt(i*4)
                );
            }
            
            const counterWords = [counter, 0];
            const nonceWords = [];
            for (let i = 0; i < 3; i++) {
                nonceWords.push(
                    (nonce.charCodeAt(i*4+3) << 24) |
                    (nonce.charCodeAt(i*4+2) << 16) |
                    (nonce.charCodeAt(i*4+1) << 8) |
                    nonce.charCodeAt(i*4)
                );
            }
            
            // Инициализация состояния
            let state = [
                constants[0], constants[1], constants[2], constants[3],
                keyWords[0], keyWords[1], keyWords[2], keyWords[3],
                keyWords[4], keyWords[5], keyWords[6], keyWords[7],
                counterWords[0], counterWords[1], nonceWords[0], nonceWords[1], nonceWords[2]
            ];
            
            // Сохраняем исходное состояние
            const initialState = state.slice();
            
            // 10 двойных раундов (20 раундов всего)
            for (let i = 0; i < 10; i++) {
                // Колонные раунды
                quarterRound(state, 0, 4, 8, 12);
                quarterRound(state, 1, 5, 9, 13);
                quarterRound(state, 2, 6, 10, 14);
                quarterRound(state, 3, 7, 11, 15);
                
                // Диагональные раунды
                quarterRound(state, 0, 5, 10, 15);
                quarterRound(state, 1, 6, 11, 12);
                quarterRound(state, 2, 7, 8, 13);
                quarterRound(state, 3, 4, 9, 14);
            }
            
            // Складываем с исходным состоянием
            for (let i = 0; i < 16; i++) {
                state[i] += initialState[i];
            }
            
            // Преобразуем в байтовый массив
            let output = new Uint8Array(64);
            for (let i = 0; i < 16; i++) {
                output[i*4] = state[i] & 0xff;
                output[i*4+1] = (state[i] >>> 8) & 0xff;
                output[i*4+2] = (state[i] >>> 16) & 0xff;
                output[i*4+3] = (state[i] >>> 24) & 0xff;
            }
            
            return output;
        }

        function chacha20(key, counter, nonce, data) {
            let output = new Uint8Array(data.length);
            
            for (let i = 0; i < data.length; i += 64) {
                const keyStream = chacha20Block(key, counter + Math.floor(i / 64), nonce);
                const blockLength = Math.min(64, data.length - i);
                
                for (let j = 0; j < blockLength; j++) {
                    output[i + j] = data[i + j] ^ keyStream[j];
                }
            }
            
            return output;
        }

        // Функции для работы с алфавитом
        function textToIndices(text, alphabet) {
            const indices = [];
            for (let i = 0; i < text.length; i++) {
                const index = alphabet.indexOf(text[i]);
                if (index === -1) {
                    throw new Error(`Символ '${text[i]}' не найден в алфавите`);
                }
                indices.push(index);
            }
            return indices;
        }

        function indicesToText(indices, alphabet) {
            let text = '';
            for (let i = 0; i < indices.length; i++) {
                text += alphabet[indices[i] % alphabet.length];
            }
            return text;
        }

        function encrypt() {
            try {
                const alphabet = document.getElementById('alphabet').value;
                if (!alphabet) {
                    throw new Error('Алфавит не может быть пустым');
                }
                
                const key = document.getElementById('key').value;
                const nonce = document.getElementById('nonce').value;
                const counter = parseInt(document.getElementById('counter').value);
                const message = document.getElementById('message').value.toUpperCase();
                
                // Проверяем, что сообщение состоит только из символов алфавита
                const messageIndices = textToIndices(message, alphabet);
                
                // Преобразуем индексы в байты
                const messageBytes = new Uint8Array(messageIndices);
                
                // Шифруем
                const cipherBytes = chacha20(key, counter, nonce, messageBytes);
                
                // Преобразуем байты обратно в индексы алфавита
                const cipherIndices = Array.from(cipherBytes).map(b => b % alphabet.length);
                
                // Преобразуем индексы в текст
                const ciphertext = indicesToText(cipherIndices, alphabet);
                
                document.getElementById('ciphertext').value = ciphertext;
                document.getElementById('result').textContent = 'Сообщение успешно зашифровано!';
            } catch (error) {
                document.getElementById('result').textContent = 'Ошибка: ' + error.message;
            }
        }

        function decrypt() {
            try {
                const alphabet = document.getElementById('alphabet').value;
                if (!alphabet) {
                    throw new Error('Алфавит не может быть пустым');
                }
                
                const key = document.getElementById('key').value;
                const nonce = document.getElementById('nonce').value;
                const counter = parseInt(document.getElementById('counter').value);
                const ciphertext = document.getElementById('ciphertext').value.toUpperCase();
                
                // Проверяем, что шифротекст состоит только из символов алфавита
                const cipherIndices = textToIndices(ciphertext, alphabet);
                
                // Преобразуем индексы в байты
                const cipherBytes = new Uint8Array(cipherIndices);
                
                // Дешифруем (процесс такой же как шифрование)
                const messageBytes = chacha20(key, counter, nonce, cipherBytes);
                
                // Преобразуем байты обратно в индексы алфавита
                const messageIndices = Array.from(messageBytes).map(b => b % alphabet.length);
                
                // Преобразуем индексы в текст
                const message = indicesToText(messageIndices, alphabet);
                
                document.getElementById('result').textContent = 'Расшифрованное сообщение: ' + message;
            } catch (error) {
                document.getElementById('result').textContent = 'Ошибка: ' + error.message;
            }
        }
    </script>
</body>
</html>
